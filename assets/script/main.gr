function randf() (real) {
    return rand(-1., 1.);
}

event onLoad() {
    let camera = getCamera();
    camera:position(0., .5, 2.);

    Light light = loadLight(LightKind.DIRECTIONAL);
    light:position(0., 1., 0.);

    Skybox skybox = loadSkybox();

    //Quad quad = loadQuad();
    //Model tree = loadModel("tree/scene");
    //Model grass = loadModel("grass/scene");
    //Model ground = loadModel("ground/scene");
    //Model bunny = loadModel("bunny/scene");
    //bunny:position(vec3(1., 1., 1.));
    //Model statue = loadModel("statue/scene");
    Model jupiter = loadModel("jupiter/scene");
    //jupiter:position(vec3(1., 0., 1.));
    //jupiter:scale(vec3(0.05, 0.05, 0.05));
    //Model crow = loadModel("crow/scene");
    Terrain terrain = loadTerrain(800.0, 128, 0, 0, "planks.png");

    int nbAsteroids = 500;

    array(mat4) instanceMatrices;

    // Radius for asteroid belt
    real radius = 50.0f;

    // Standard deviation from radius
    real radiusDeviation = 5f;

    // Gets stuck?
    loop(nbAsteroids) {
        real x = randf();
        real y = (rand(0, 1) * 2 - 1) * sqrt(1.0f - x * x);

        real finalRadius = radius + randf() * radiusDeviation;
        
        vec3 position;
        if (randf() > 0.5f) {
            position = vec3(y * finalRadius, randf(), x * finalRadius);
        } else {
            position = vec3(x * finalRadius, randf(), y * finalRadius);
        }

        quat rotation = quat(1., randf(), randf(), randf());
        vec3 scale = vec3(0.1, 0.1, 0.1);

        mat4 instanceMatrix = packInstanceMatrix(position, rotation, scale);
        instanceMatrices ~= instanceMatrix;
    }

    Model asteroid = loadModel("asteroid/scene", nbAsteroids, instanceMatrices);
}